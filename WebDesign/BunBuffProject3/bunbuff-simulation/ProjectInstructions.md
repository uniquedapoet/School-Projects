In this project, the overarching learning objective is to transform a specification into an interactive web application, which will require making design decisions, explaining and justifying those decisions in a design document, and then building the web application based on your design. The submission for this project will include two pieces: (1) the web application, and (2) the design document.

The web application that you are building is a simulation game with a particular set of rules. In the game, you are simulating an island on the planet Buffosphere, populated by creatures known as bunbuffs. The bunbuffs live on an M by N grid, where M and N are set at the start of the simulation. A few other numbers should be set at the start of the simulation as well: (1) the size of the initial population of bunbuffs, (2) the maximum lifespan of a bunbuff in months (which is the same for every bunbuff), (3) the maximum size of a bunbuff litter, (4) the minimum aggression level of a bunbuff, and (5) the maximum aggression level of a bunbuff. Note that to prevent user error, you should make sure that the user can only enter positive integers for each of these simulation parameters. Furthermore, for parameters (4) and (5), you should make sure that the number is between 1 and 99, inclusive.

After the user enters these numbers, they should be able to click a button to start the simulation. At this point, you should show the user the initial state of the simulation. When setting the initial state, you should randomly place each bunbuff in the initial population on a grid cell such that there are no more than two bunbuffs per cell. If there is not enough room in the grid to fit all of the bunbuffs, then you should cap the size of the initial population such that it fits in the grid. You should also randomly set each bunbuff's other attributes, which you'll learn more about by reading through the rest of this specification.

At this point, the user should be able to play the game by clicking a button that advances the simulation by one step per click. Each step of the simulation represents one month passing on Buffosphere. Several things should happen during the step in the order described below.

At the start of the step, each bunbuff should hop to a randomly-selected grid cell that is adjacent to its current location and that has no more than one bunbuff already located on it. If no such grid cell exists, then the bunbuff should not move. Note that "adjacent" here includes diagonals, not only the cardinal directions. Also note that bunbuffs cannot go off the grid, and the edges of the grid are considered the edge of the island (i.e., it is not possible to "wrap around" from one side of the grid to the other). The order in which you choose to have each bunbuff on the grid hop can be arbitrary.

After each bunbuff hops (or tries to hop) to a new cell, the following should happen in your game. First, you should determine whether any of the bunbuffs pass away from natural causes. The probability of a bunbuff dying from natural causes is computed as the bunbuff's current age in months divided by the maximum lifespan of a bunbuff as set at the start of the simulation. When a bunbuff dies, you should remove it from the game.

After simulating bunbuffs passing away from natural causes, you should then determine whether any bunbuffs attack each other. Bunbuffs only attack each other when they are on the same cell. Whether or not a bunbuff attacks another bunbuff is based on its aggression level. The aggression level of a bunbuff is a fixed integer, randomly selected for each bunbuff, that is no less than the minimum aggression level and no greater than the maximum aggression level that were set at the start of the simulation. The aggression level represents the percentage probability of that bunbuff attacking another bunbuff on the cell. If two bunbuffs attack each other, they both die. If one bunbuff attacks another bunbuff that doesn't attack back, then the bunbuff that was attacked dies. As stated previously, any deceased bunbuffs should be removed from the game.

After simulating bunbuffs attacking each other, you should then simulate whether any of the bunbuffs reproduce. Bunbuffs will reproduce if they are both on the same cell, both at least six months old, and there is an adjacent cell with room for a new bunbuff (i.e., there must be fewer than two bunbuffs already on the cell). A newly-born bunbuff should be placed on an eligible adjacent cell that was randomly selected, and its age should be set to zero months since it was just born. The size of the bunbuff litter should be equal to the maximum size of a bunbuff litter, unless there are not enough available spots in the adjacent cells to fit all of the bunbuffs. In that case, the size of the bunbuff litter should be equal to the number of available spots in the adjacent cells. The order in which you choose to have bunbuffs on the grid reproduce can be arbitrary.

At this point, the simulation step should end. As previously stated, each simulation step represents the passage of one month, so you should increase the age of each bunbuff by one month at the end of the simulation step.

The user should always be able to advance the simulation to the next step unless there are zero bunbuffs left on the grid. If there are no bunbuffs left, then nothing further can happen in the simulation, so you should prevent the user from being able to advance to the next step. Regardless of whether or not the simulation can be advanced a step, the user should always be able to restart the simulation and have the option of entering new simulation parameters if they wish.

Your simulation game should provide all details to the user that are necessary to understand what is going on before the simulation starts and after each step of the simulation. To this end, the interface of your game should include a grid with a representation of each bunbuff in it. The interface should also include a section with messages describing what happened during each step (e.g., "Bunbuff 11 died from natural causes" or "Bunbuff 4 attacked and killed Bunbuff 7"). There should also be a way for the user to see all of the attributes of each bunbuff and connect those to the bunbuffs that they see in the grid. Both the structure and the appearance of these user interface components are up to you to design (feel free to be creative!), but one thing to keep in mind is that there shouldn't be any ambiguity to the user about what is happening during the simulation.

Lastly, your interface should also include some summary statistics that update after every step of the simulation: (1) the current step of the simulation, (2) the average number of bunbuffs born per month, (3) the average number of bunbuff deaths per month, (4) the average lifespan of a bunbuff in months, (5) the number of bunbuffs that are currently on the grid, and (6) the total number of bunbuffs that have existed during the course of the current simulation.

You'll need to record the details of your design process within a document so that I'll be able to understand how you approached the process. The design document should capture the following: (1) how you've designed the application state and the flow for updating the state, (2) why you've designed the application state and the flow for updating the state the way that you did among the possible alternatives, (3) how you've designed the components and layout of the user interface, and (4) why you've designed the components and layout of the user interface the way that you did among the possible alternatives. If you've included all of the necessary details in your design document, then I shouldn't be surprised by anything when I review your code and application. Put another way, after reading your design document, I should be able to go and roughly recreate the application that you built â€” not at the level of having identical variable names but at the level of having approximately the same application state, flow for updating the state, user interface components, and user interface layout.

You may use either regular JavaScript or React to build the interactivity into the game, but you can't use any external JavaScript libraries other than React, ReactDOM, and Babel. Your submission should be an archive file (such as a ZIP file) containing all of the files needed for your web application plus a PDF of your design document. I am expecting to be able to download your submission, unzip the file, and then launch a Python web server from the unzipped directory. It is your responsibility to make sure that what you submit contains a working web application and your design document; if you have questions about the format, ask me well in advance of the submission deadline. Also note that I need to be able to read your code, so DO NOT submit code that has been bundled, split, transpiled, or minified by a tool in any way.

Your submission will be graded on the following criteria:

A. (Weight: 20%) Does your design document appropriately and completely address all of the details in the game specification?
B. (Weight: 12%) Does your design document detail your approach to application state, flow for updating the state, user interface components, and user interface layout?
C. (Weight: 12%) Does your design document justify your approach to application state, flow for updating the state, user interface components, and user interface layout?
D. (Weight: 20%) Does your implemented web application match your design document?
E. (Weight: 36%) Does your web application work correctly, providing the user with a bug-free experience?
For each criterion, the grade categories will correspond to fully (grade 4), mostly (grade 3), somewhat (grade 2), a little bit (grade 1), or not at all (grade 0).